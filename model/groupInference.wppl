// run using, e.g.:
// webppl arbitrariness.wppl --require ./refModule/ --require webppl-csv -- --gameNum 'game1'

// inference of speaker choosing an utterance
var S = function(object, posterior, params) {
  var modelS = function () {
    // determining which community
    // var z = sample(Discrete({ps: params.groupDist}))
    // var community = posterior.groupUtt[z];

    // utterance chosen based on what they know about the community
    // var utt = categorical({ps: community, vs: params.utterances});

    var utt = uniformDraw(params.utterances);
        var inf = expectation(posterior, function(lexicon) {
          return sharedInference.getL0Score(object, utt, extend(params, {lexicon: lexicon[params.partnerID]}));
        });
        var utility = ((1-params.costWeight) * inf
                       - params.costWeight * sharedInference.getUttCost(utt));

        factor(params.speakerAlpha * utility);
    return utt;
  }
  return Infer({method: "enumerate"}, modelS);
};

// inference of listener choosing an object
var L = function(utt, posterior, params) {
    // object chosen based on speaker community
    // var z = sample(Discrete({ps: params.groupDist}))
    // var community = posterior.groupObj[z];

    // var object = categorical({ps: community, vs: params.objects});
  var modelL = function () {
    var object = uniformDraw(params.context);
        var utility = expectation(posterior, function(lexicon) {
          return sharedInference.getS1Score(utt, object, extend(params, {lexicon: lexicon[params.partnerID]}));
        });
        factor(params.listenerAlpha * utility);
        return object;
  }
  return Infer({method: "enumerate"}, modelL);
};

var updatePosterior = function(data, lexicalPrior, params) {
  return Infer(params.inferOptions, function() {
    // global prototype
    var lexicon = lexicalPrior();

    // guessing the community
        // var groupUtt = repeat(params.numGroups, function (){
        //   // distribution within each community
        //   return dirichlet({alpha: ones([params.utterances.length, 1])})
        // })
        // var groupObj = repeat(params.numGroups, function (){
        //   // distribution within each community
        //   return dirichlet({alpha: ones([params.objects.length, 1])})
        // })

        // mapData({data: data}, function(trial) {
        //    var beta = Math.pow(params.discountFactor,  data.length - trial.trialNum);
        //    var object = trial.role == 'speaker' ? trial.clickedName : trial.intendedName;
        //    var trialParams = extend(params, {context: trial.context, lexicon: lexicon[trial.partnerID]});
        //    if(trial.role == 'speaker') {
        //      factor(beta * refModule.getL0Score(object, trial.wordID, trialParams));
        //    } else {
        //      factor(beta * refModule.getSpeakerScore(trial.wordID, object, trialParams));
        //    }
        // });

        // return {groupUtt: groupUtt.data, groupObj: groupObj.data};

    mapData({data: data}, function(trial) {
      var beta = Math.pow(params.discountFactor,  data.length - trial.trialNum);
      var object = trial.role == 'speaker' ? trial.clickedName : trial.intendedName;
      var trialParams = extend(params, {context: trial.context, lexicon: lexicon[trial.partnerID]});
      if(trial.role == 'speaker') {
        factor(beta * sharedInference.getL0Score(object, trial.wordID, trialParams));
      } else {
        factor(beta * sharedInference.getS1Score(trial.wordID, object, trialParams));
      }
    });
    return lexicon;
  });
};

var utterances = ['word1', 'word2'];
var objects = ['circle', 'square'];
var meanings = ['circle', 'square'];
var numMeanings = meanings.length;
var groups = ['red', 'blue'];
var numGroups = groups.length;
var groupDist = dirichlet({alpha: ones([numGroups, 1])});

var params = {
  speakerAlpha : 1,
  listenerAlpha: 1,
  discountFactor: 0.5,
  guessingEpsilon: 1,
  costWeight: 0,
  numTrials: 40,
  context : objects,
  partnerID: 1,
  utterances: utterances,
  objects: objects,
  // inferOptions: {method: 'MCMC', samples: 1000}
  inferOptions: {method: 'enumerate'}
};

var pragStr = ('discount:' + params.discountFactor);
var outputFile = csv.open('./output/arbitrariness_trajectory_' + pragStr + '_' + argv.gameNum + '.csv');
var header = 'gameNum,speakerAlpha,listenerAlpha,costWeight,discountFactor,guessingEpsilon,\
              trialNum,speakerID,listenerID,intendedName,topSpeakerChoice,topListenerChoice,correct';
csv.writeLine(header, outputFile);

var lexicalPrior = function() {
  return {'1' : _.zipObject(utterances, map(function(utt) {
    return sample(Categorical({vs: meanings}));
  }, utterances))};
};

var writeLine = function(iterationNum, currTrial, topListenerChoice, topSpeakerChoice) {
  csv.writeLine([
    iterationNum, params.speakerAlpha, params.listenerAlpha, params.costWeight, params.discountFactor, params.guessingEpsilon,
    currTrial.trialNum, currTrial.speakerID, currTrial.listenerID, currTrial.intendedName,
    topSpeakerChoice, topListenerChoice,
    topListenerChoice == currTrial.intendedName
  ].join(','), outputFile);
};


// for each point in data, we want the model's predictions
var iterate = function(iterationNum, dataSoFar) {
  var trialNum = dataSoFar[1].length;
  var currTrial = {
    intendedName: uniformDraw(objects),
    trialNum: trialNum,
    partnerID: 1,
    context: objects,
    speakerID: (trialNum % 2) == 0 ? 1 : 2,
    listenerID: (trialNum % 2) == 0 ? 2 : 1
  };

  var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID], lexicalPrior, params);
  var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID], lexicalPrior, params);

  // get marginal prediction of next data point over lexicon posterior
  var speakerOutput = S(currTrial.intendedName, speakerPosterior, params);
  var topSpeakerChoice =  sample(speakerOutput);

  var listenerOutput = L(topSpeakerChoice, listenerPosterior, params);
  var topListenerChoice =  sample(listenerOutput);

  writeLine(params, currTrial, topListenerChoice, topSpeakerChoice);
  if(currTrial.trialNum < params.numTrials) {
    var ids = [currTrial.speakerID, currTrial.listenerID];
    iterate(iterationNum, _.zipObject(ids, map(function(id) {
      return dataSoFar[id].concat(extend(currTrial, {
        role : id == currTrial.speakerID ? 'speaker' : 'listener',
        wordID : topSpeakerChoice,
        clickedName : topListenerChoice
      }));
    }, ids)));
  }
};

map(function(i) {
  console.log('iteration', i);
  iterate(i, {1: [], 2: []});
}, _.range(5));
csv.close(outputFile);