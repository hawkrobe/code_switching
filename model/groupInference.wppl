// run using, e.g.:
// webppl groupInference.wppl --require ./sharedInference/ --require webppl-csv -- --gameNum 'game1'

// inference of speaker choosing an utterance
var S = function(object, posterior, params) {
  var modelS = function () {
    // determining which community
    // var z = sample(Discrete({ps: params.groupDist}))
    // var community = posterior.groupUtt[z];

    // utterance chosen based on what they know about the community
    // var utt = categorical({ps: community, vs: params.utterances});

    var utt = uniformDraw(params.utterances);
    var inf = expectation(posterior, function(lexicon) {
       return sharedInference.getL0Score(object, utt, extend(params, {lexicon: lexicon[params.partnerID]}));
    });
    var utility = ((1-params.costWeight) * inf
                    - params.costWeight * sharedInference.getUttCost(utt));

    factor(params.speakerAlpha * utility);

    // context 1
    // if speakerID = 1 or 3 then if object = A...
    if (params.speakerID == 1 || params.speakerID == 3) {
        if (object == params.objects[0]) {
            condition(utt == params.utterances[0])
        } else {
            condition(utt == params.utterances[1])
        }
    } else { // if speakerID = 2 or 4 then if object = A...
        if (object == params.objects[0]) {
            condition(utt == params.utterances[1])
        } else {
            condition(utt == params.utterances[0])
        }
    }

    return utt;
  }
  return Infer({method: 'enumerate'}, modelS);
};

// inference of listener choosing an object
var L = function(utt, posterior, params) {
    // object chosen based on speaker community
    // var z = sample(Discrete({ps: params.groupDist}))
    // var community = posterior.groupObj[z];

    // var object = categorical({ps: community, vs: params.objects});
  var modelL = function () {
    var object = uniformDraw(params.context);
    var utility = expectation(posterior, function(lexicon) {
      return sharedInference.getS1Score(utt, object, extend(params, {lexicon: lexicon[params.partnerID]}));
    });
    factor(params.listenerAlpha * utility);
    return object;
  }
  return Infer({method: 'enumerate'}, modelL);
};

var updatePosterior = function(data, lexicalPrior, params) {
  console.log('updating posterior')
  return Infer(params.inferOptions, function() {
    // global prototype
    var lexicon = lexicalPrior().lexicon;

    // guessing the community
        // var groupUtt = repeat(params.numGroups, function (){
        //   // distribution within each community
        //   return dirichlet({alpha: ones([params.utterances.length, 1])})
        // })
        // var groupObj = repeat(params.numGroups, function (){
        //   // distribution within each community
        //   return dirichlet({alpha: ones([params.objects.length, 1])})
        // })

        // return {groupUtt: groupUtt.data, groupObj: groupObj.data};

    mapData({data: data}, function(trial) {
      var beta = Math.pow(params.discountFactor,  data.length - trial.trialNum);
      var object = trial.role == 'speaker' ? trial.clickedName : trial.intendedName;
      var trialParams = extend(params, {context: trial.context, lexicon: lexicon[trial.partnerID]});
      if(trial.role == 'speaker') {
        factor(beta * sharedInference.getL0Score(object, trial.wordID, trialParams));
      } else {
        factor(beta * sharedInference.getS1Score(trial.wordID, object, trialParams));
      }
    });
    return lexicon;
  });
};

var utterances = ['word1', 'word2'];
var objects = ['A', 'B'];
var meanings = ['A', 'B'];
var numMeanings = meanings.length;
var groups = ['group1', 'group2'];
var numGroups = groups.length;
var groupDist = dirichlet({alpha: ones([numGroups, 1])});
var partners = ['partner1', 'partner2', 'partner3', 'partner4', 'partner5'];

var params = {
  speakerAlpha : 5,
  listenerAlpha: 5,
  discountFactor: 0.5,
  guessingEpsilon: 0.01,
  costWeight: 0,
  numTrials: 20,
  context : objects,
  // partnerID: 1,
  utterances: utterances,
  objects: objects,
  inferOptions: {method: 'MCMC', samples: 2500, burn:5000, lag:5, verbose: true}
  // inferOptions: {method: 'enumerate'}
};

var f = csv.open('./output/' + argv.model + argv.chainNum + '.csv');
csv.writeLine('model,chainNum,speakerAlpha,listenerAlpha,costWeight,discountFactor,guessingEpsilon,\
              trialNum,speakerID,listenerID,partnerID,intendedName,speakerChoice,listenerChoice,\
              longUttScore,correctProb', f);

var writeLine2 = function(currTrial, speakerChoice, listenerChoice, speakerOutput, listenerOutput) {
  csv.writeLine([
    params.model, params.chainNum, params.speakerAlpha, params.listenerAlpha,
    params.costWeight, params.discountFactor, params.guessingEpsilon,
    currTrial.trialNum, currTrial.speakerID, currTrial.listenerID, currTrial.partnerID,
    currTrial.intendedName, speakerChoice, listenerChoice,
    Math.exp(speakerOutput.score('word1_word2')) + Math.exp(speakerOutput.score('word3_word4')),
    listenerOutput.score(currTrial.intendedName),
  ].join(','), f);
};

var sampleProbs = function() {
  var hyperScale = exponential({a:1});
  return T.mul(ones([numMeanings, 1]), hyperScale);
}

var lexicalPrior = function() {
  var groupAssignmentZ = {
    'partner1': uniformDraw(groups),
    'partner2': uniformDraw(groups),
    'partner3': uniformDraw(groups),
    'partner4': uniformDraw(groups),
    'partner5': uniformDraw(groups)
  }

  var partnerMeaning = map(function(utt){
    var hyperParams = {
      'group1': dirichlet(sampleProbs()),
      'group2': dirichlet(sampleProbs())
    };
    return map(function(partnerID) {
      var partnerGroup = groupAssignmentZ[partnerID];
      return categorical({vs: meanings, ps: hyperParams[partnerGroup]});
    }, partners);
  }, utterances);

  return {
    'groupAssignment': groupAssignmentZ,
    'lexicon': {
        '1': {
            'word1': partnerMeaning[0][0], 'word2': partnerMeaning[1][0]
        },
        '2': {
            'word1': partnerMeaning[0][1], 'word2': partnerMeaning[1][1]
        },
        '3': {
            'word1': partnerMeaning[0][2], 'word2': partnerMeaning[1][2]
        },
        '4': {
            'word1': partnerMeaning[0][3], 'word2': partnerMeaning[1][3]
        },
        '5': {
            'word1': partnerMeaning[0][4], 'word2': partnerMeaning[1][4]
        }
    }
  }
};

var iterate2 = function(outputF, remainingTrials, dataSoFar) {
  var currTrial = extend(first(remainingTrials), {
    context : objects,
  });

  console.log('Trial Number: ' + currTrial.trialNum);
  console.log('Partner ID: ' + currTrial.partnerID);
  // run VI on current data
  var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID], lexicalPrior, params);
  var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID], lexicalPrior, params);

  // get marginal prediction of next data point over lexicon posterior
  var trialParams = extend(params, {partnerID: currTrial.partnerID, speakerID: currTrial.speakerID});
  var speakerOutput = S(currTrial.intendedName, speakerPosterior, trialParams);
  var nextUtt = sample(speakerOutput);

  var listenerOutput = L(nextUtt, listenerPosterior, trialParams);
  var nextChoice = sample(listenerOutput);

  writeLine2(currTrial, nextUtt, nextChoice, speakerOutput, listenerOutput);
  var newDataSoFar = _.zipObject(_.range(1, 6), map(function(id) {
    var trialPacket = extend(currTrial, {
      role: id == currTrial.speakerID ? "speaker" : "listener",
      wordID: nextUtt,
      clickedName: nextChoice
    });
    return (id == currTrial.speakerID || id == currTrial.listenerID ?
            dataSoFar[id].concat(trialPacket) : dataSoFar[id]);
  }, _.range(1, 6))); // UPDATE FOR ID?

  if(!_.isEmpty(rest(remainingTrials))) {
    iterate2(outputF, rest(remainingTrials), newDataSoFar);
  }
};

var trials = [

// Context 1 Set: Same listener for all trials, Group 1: 1 & 3, Group 2: 2 & 4 --------------------------------
// Group 1 refers to A as "word1" and B as "word2"
// Group 2 refers to A as "word2" and B as "word1"

  {trialNum: 1, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'A'},
  {trialNum: 2, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'B'},
  {trialNum: 3, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'A'},
  {trialNum: 4, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'B'},
  {trialNum: 5, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'A'},
  {trialNum: 6, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'B'},
  {trialNum: 7, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'A'},
  {trialNum: 8, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'B'},
  {trialNum: 9, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'A'},
  {trialNum: 10, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'B'},
  {trialNum: 11, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'A'},
  {trialNum: 12, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'B'},
  {trialNum: 13, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'A'},
  {trialNum: 14, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'B'},
  {trialNum: 15, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'A'},
  {trialNum: 16, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'B'}

];

iterate2(f, trials, {1: [], 2:[], 3:[], 4:[], 5 :[]});
csv.close(f);
