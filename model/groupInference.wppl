// run using, e.g.:
// webppl groupInference.wppl --require ./sharedInference/ --require webppl-csv -- --gameNum 'game1'

// inference of speaker choosing an utterance
var S = function(object, posterior, params) {
  var modelS = function () {
    // determining which community
    // var z = sample(Discrete({ps: params.groupDist}))
    // var community = posterior.groupUtt[z];
    // utterance chosen based on what they know about the community
    // var utt = categorical({ps: community, vs: params.utterances});

    var utt = uniformDraw(params.utterances);
    var inf = expectation(marginalize(posterior, 'lexicon'), function(lexicon) {
       return sharedInference.getL0Score(object, utt, extend(params, {lexicon: lexicon[params.partnerID]}));
    });
    var utility = ((1-params.costWeight) * inf
                    - params.costWeight * sharedInference.getUttCost(utt));

    factor(params.speakerAlpha * utility);

    // context 1
    // if speakerID = 1 or 3 then if object = A...
    //if (params.speakerID == 1 || params.speakerID == 3) {
    //    if (object == params.objects[0]) {
    //        condition(utt == params.utterances[0])
    //    } else {
    //        condition(utt == params.utterances[1])
    //    }
    //} else { // if speakerID = 2 or 4 then if object = A...
    //    if (object == params.objects[0]) {
    //        condition(utt == params.utterances[1])
    //    } else {
    //        condition(utt == params.utterances[0])
    //    }
    //}
    return utt;
  }
  return Infer({method: 'enumerate'}, modelS);
};

// inference of listener choosing an object
var L = function(utt, posterior, params) {
    // object chosen based on speaker community
    // var z = sample(Discrete({ps: params.groupDist}))
    // var community = posterior.groupObj[z];
    // var object = categorical({ps: community, vs: params.objects});

  var modelL = function () {
    var object = uniformDraw(params.context);
    var utility = expectation(marginalize(posterior, 'lexicon'), function(lexicon) {
      return sharedInference.getS1Score(utt, object, extend(params, {lexicon: lexicon[params.partnerID]}));
    });
    factor(params.listenerAlpha * utility);
    return object;
  }
  return Infer({method: 'enumerate'}, modelL);
};

var updatePosterior = function(data, lexicalPrior, params) {
  console.log('updating posterior')
  return Infer(params.inferOptions, function() {
    // global prototype
    var prior = lexicalPrior();
    var lexicon = prior.lexicon;
    //console.log(lexicon);
    var groupAssignment = prior.groupAssignment;
    var hyper1 = prior.group1hyperParams;
    var hyper2 = prior.group2hyperParams;
    //console.log(groupAssignment)
    //console.log(hyper1)
    //console.log(hyper2)

    mapData({data: data}, function(trial) {
      var beta = Math.pow(params.discountFactor,  data.length - trial.trialNum);
      var object = trial.role == 'speaker' ? trial.clickedName : trial.intendedName;
      var trialParams = extend(params, {context: trial.context, lexicon: lexicon[trial.partnerID]});
      if(trial.role == 'speaker') {
        factor(beta * sharedInference.getL0Score(object, trial.wordID, trialParams));
      } else {
        factor(beta * sharedInference.getS1Score(trial.wordID, object, trialParams));
      }
    });
    return {lexicon: lexicon, groupAssignment: groupAssignment};
  });
};

var utterances = ['word1', 'word2'];
var objects = ['A', 'B'];
var meanings = ['A', 'B'];
var numMeanings = meanings.length;
var groups = ['group1', 'group2'];
var numGroups = groups.length;
var groupDist = dirichlet({alpha: ones([numGroups, 1])});
var partners = ['partner1', 'partner2', 'partner3', 'partner4'];
var model = 'M1';

var params = {
  speakerAlpha : 5,
  listenerAlpha: 5,
  discountFactor: 0.9,
  guessingEpsilon: 0.01,
  costWeight: 0,
  numTrials: 20,
  context : objects,
  utterances: utterances,
  objects: objects,
  inferOptions: {method: 'MCMC', samples: 10000, burn:5000, lag:5, verbose: true},
  model: model
};

// model 1 - completely distinct groups with opposite lexicons, single listener

var f = csv.open('./output/' + model + '.csv');
csv.writeLine('model,speakerAlpha,listenerAlpha,costWeight,discountFactor,guessingEpsilon,\
              trialNum,speakerID,listenerID,partnerID,intendedName,speakerChoice,listenerChoice,\
              longUttScore,correctProb', f);

var posttest_file = csv.open('./output/meaningTest_' + model + '.csv');
csv.writeLine('model,speakerAlpha,listenerAlpha,discountFactor,guessingEpsilon,trialNum,\
                  condition,partnerID,partner,val', posttest_file);

var writeLine2 = function(currTrial, speakerChoice, listenerChoice, speakerOutput, listenerOutput) {
  csv.writeLine([
    params.model, params.speakerAlpha, params.listenerAlpha,
    params.costWeight, params.discountFactor, params.guessingEpsilon,
    currTrial.trialNum, currTrial.speakerID, currTrial.listenerID, currTrial.partnerID,
    currTrial.intendedName, speakerChoice, listenerChoice,
    Math.exp(speakerOutput.score('word1_word2')) + Math.exp(speakerOutput.score('word3_word4')),
    listenerOutput.score(currTrial.intendedName),
  ].join(','), f);
};

var sampleProbs = function() {
  var hyperScale = exponential({a:1});
  return T.mul(ones([numMeanings, 1]), hyperScale);
}

var lexicalPrior = function() {
  var groupAssignmentZ = {
    'partner1': 'group1',
    'partner2': uniformDraw(groups),
    'partner3': uniformDraw(groups),
    'partner4': uniformDraw(groups),
    //'partner5': uniformDraw(groups)
  }

  var meaning = map(function(utt){
    var hyperParams = {
      'group1': dirichlet(sampleProbs()),
      'group2': dirichlet(sampleProbs())
    };
    return {
        group1hyperParams: hyperParams['group1'],
        group2hyperParams: hyperParams['group2'],
        partnerMeaning: map(function(partnerID) {
          var partnerGroup = groupAssignmentZ[partnerID];
          return categorical({vs: meanings, ps: hyperParams[partnerGroup]});
        }, partners)
    };
  }, utterances);

  return {
    'groupAssignment': groupAssignmentZ,
    'group1hyperParams' : {'word1': meaning[0].group1hyperParams, 'word2' : meaning[1].group1hyperParams},
    'group2hyperParams' : {'word1': meaning[0].group2hyperParams, 'word2' : meaning[1].group2hyperParams},
    'lexicon': {
        '1': {
            'word1': meaning[0].partnerMeaning[0], 'word2': meaning[1].partnerMeaning[0]
        },
        '2': {
            'word1': meaning[0].partnerMeaning[1], 'word2': meaning[1].partnerMeaning[1]
        },
        '3': {
            'word1': meaning[0].partnerMeaning[2], 'word2': meaning[1].partnerMeaning[2]
        },
        '4': {
            'word1': meaning[0].partnerMeaning[3], 'word2': meaning[1].partnerMeaning[3]
        }
        //'5': {
        //    'word1': meaning[0].partnerMeaning[4], 'word2': meaning[1].partnerMeaning[4]
        //}
    }
  }
};

var postTest = function(trial, posterior){
    var data = [params.model, params.speakerAlpha, params.listenerAlpha, params.discountFactor, params.guessingEpsilon,
               trial.trialNum];
    map(function(partner){
        //console.log(marginalize(posterior, function(x){return x[partner]}))
        sharedInference.writeMarginals(marginalize(posterior, function(x) {return x[partner];}),
                           posttest_file, data.concat([trial.speakerID, partner]));
    }, partners);
}

csv.writeLine('model,speakerAlpha,listenerAlpha,discountFactor,guessingEpsilon,trialNum,\
                  condition,agentID,object,word,val', posttest_file);

var iterate2 = function(outputF, remainingTrials, dataSoFar) {
  var currTrial = extend(first(remainingTrials), {
    context : params.context,
  });

  console.log('Trial Number: ' + currTrial.trialNum);
  console.log('Partner ID: ' + currTrial.partnerID);
  //console.log(dataSoFar);
  // run VI on current data
  var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID], lexicalPrior, params);
  //console.log(dataSoFar[currTrial.listenerID]);
  var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID], lexicalPrior, params);
  postTest(currTrial, marginalize(listenerPosterior, 'groupAssignment'));

  // get marginal prediction of next data point over lexicon posterior
  var trialParams = extend(params, {partnerID: currTrial.partnerID, speakerID: currTrial.speakerID});
  var speakerOutput = S(currTrial.intendedName, speakerPosterior, trialParams);
  var nextUtt = sample(speakerOutput);
  //var nextUtt = currTrial.wordID;

  var listenerOutput = L(nextUtt, listenerPosterior, trialParams);
  var nextChoice = sample(listenerOutput);

  //console.log(marginalize(listenerPosterior, 'groupAssignment'))

  writeLine2(currTrial, nextUtt, nextChoice, speakerOutput, listenerOutput);
  var newDataSoFar = _.zipObject(_.range(1, 6), map(function(id) {
    var trialPacket = extend(currTrial, {
      role: id == currTrial.speakerID ? "speaker" : "listener",
      wordID: nextUtt,
      clickedName: nextChoice
    });
    return (id == currTrial.speakerID || id == currTrial.listenerID ?
            dataSoFar[id].concat(trialPacket) : dataSoFar[id]);
  }, _.range(1, 6)));

  if(!_.isEmpty(rest(remainingTrials))) {
    iterate2(outputF, rest(remainingTrials), newDataSoFar);
  }
};

var trials = [

// Context 1 Set: Same listener for all trials, Group 1: 1 & 3, Group 2: 2 & 4 --------------------------------
// Group 1 refers to A as "word1" and B as "word2"
// Group 2 refers to A as "word2" and B as "word1"

  {trialNum: 1, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'A', wordID: 'word1'},
  {trialNum: 2, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'B', wordID: 'word2'},
  {trialNum: 3, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'A', wordID: 'word1'},
  {trialNum: 4, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'B', wordID: 'word2'},
  {trialNum: 5, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'A', wordID: 'word1'},
  {trialNum: 6, speakerID: 1, listenerID: 5, partnerID: 1, intendedName: 'B', wordID: 'word2'},
  {trialNum: 7, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'A', wordID: 'word2'},
  {trialNum: 8, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'B', wordID: 'word1'},
  {trialNum: 9, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'A', wordID: 'word2'},
  {trialNum: 10, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'B', wordID: 'word1'},
  {trialNum: 11, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'A', wordID: 'word2'},
  {trialNum: 12, speakerID: 2, listenerID: 5, partnerID: 2, intendedName: 'B', wordID: 'word1'},
  {trialNum: 13, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'A', wordID: 'word1'},
  {trialNum: 14, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'B', wordID: 'word2'},
  {trialNum: 15, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'A', wordID: 'word1'},
  {trialNum: 16, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'B', wordID: 'word2'},
  {trialNum: 17, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'A', wordID: 'word1'},
  {trialNum: 18, speakerID: 3, listenerID: 5, partnerID: 3, intendedName: 'B', wordID: 'word2'},
  {trialNum: 19, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'A', wordID: 'word2'},
  {trialNum: 20, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'B', wordID: 'word1'},
  {trialNum: 21, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'A', wordID: 'word2'},
  {trialNum: 22, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'B', wordID: 'word1'},
  {trialNum: 23, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'A', wordID: 'word2'},
  {trialNum: 24, speakerID: 4, listenerID: 5, partnerID: 4, intendedName: 'B', wordID: 'word1'}

];

iterate2(f, trials, {1: [], 2:[], 3:[], 4:[], 5 :[]});
csv.close(f);
csv.close(posttest_file);