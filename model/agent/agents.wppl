// inference of speaker choosing an utterance
var S = function (object, posterior, params) {
  return Infer({ method: 'enumerate' }, function () {
    var utt = uniformDraw(params.utterances);
    var inf = expectation(marginalize(posterior, 'lexicon'), function (lexicon) {
      return agent.getL0Score(object, utt, extend(params, { lexicon: lexicon[params.partnerID] }));
    });
    var utility = ((1 - params.costWeight) * inf
      - params.costWeight * agent.getUttCost(utt));

    factor(params.speakerAlpha * utility);
    return utt;
  })
};


// inference of listener choosing an object
var L = function (utt, posterior, params) {
  return Infer({ method: 'enumerate' }, function () {
    var object = uniformDraw(params.context);
    var utility = expectation(marginalize(posterior, 'lexicon'), function (lexicon) {
      return agent.getS1Score(utt, object, extend(params, { lexicon: lexicon[params.partnerID] }));
    });
    factor(params.listenerAlpha * utility);
    return object;
  });
};

var updatePosterior = function (data, lexicalPrior, params) {
  return Infer(params.inferOptions, function () {
    var prior = lexicalPrior();
    var lexicon = prior.lexicon;
    var groupAssignment = prior.groupAssignment;
    // var hyper1 = prior.hyperParams.group1hyperParams;
    // var hyper2 = prior.hyperParams.group2hyperParams;

    // var getLexicon = mem(function(id) {return lexicon[id]});
    var getGroup = mem(function(id) {return groupAssignment[id]}) // not needed now
    var hypers = prior.hyperParams;
    // console.log(hypers)
    mapData({ data: data }, function (trial) {
      var group = getGroup(trial.partnerID)
      var beta = Math.pow(params.discountFactor, data.length - trial.trialNum);
      var object = trial.role == 'speaker' ? trial.clickedName : trial.intendedName;
      var trialParams = extend(params, { context: trial.context, lexicon: lexicon[trial.partnerID] });
      if (trial.role == 'speaker') {
        factor(beta * agent.getL0Score(object, trial.wordID, trialParams));
      } else {
        factor(beta * agent.getS1Score(trial.wordID, object, trialParams));
      };

    });

    var sameGroupAsPartner0 = {
      partner0: groupAssignment['partner0'] == groupAssignment['partner0'],
      partner1: groupAssignment['partner0'] == groupAssignment['partner1'],
      partner2: groupAssignment['partner0'] == groupAssignment['partner2'],
      partner3: groupAssignment['partner0'] == groupAssignment['partner3']
    }

    return {
      lexicon: lexicon,
      groupAssignment: groupAssignment,
      hyperParams: hypers,
      sameGroup0: sameGroupAsPartner0

      // hyperParams: {
      //   group1hyper: hyper1,
      //   group2hyper: hyper2
      // } // what's the point of this?
    };
  });
};

//// Stick-breaking construction of Dirichlet process

// var sampleGroup = function (alpha) {  // Sample group for a single participant
//   var sticks = mem(function (index) { return beta(1, alpha) });

//   var pickStick = function (sticks, J) {
//     return flip(sticks(J)) ? J : pickStick(sticks, J + 1);
//   };

//   var groupIdx = pickStick(sticks, 0);

//   // Assign label to group
//   return 'group' + groupIdx
// }


// var sampleGroups = function (nPartners, alpha) {  // Sample groups for n participants
//   var _partners = mapN(function (x) { return 'partner' + x }, nPartners);
//   var _assignments = mapN(sampleGroup(alpha), nPartners)

//   var result = agent.convertToObj(_partners, _assignments)
//   return result
// }



// var makeSticks = function(alpha) {
//   var sticks = mem(function(index) {return beta(1, alpha)});
//   return function() {
//     return pickStick(sticks, 0)
//   };
// }

// var mySticks = makeSticks(1)

// console.log(pickStick(sticks, 0))

//// CRP stuff

/*
Sample from Chinese Restaurant Process distribution

`CRP(n, alpha)` outputs an object where
tableCounts: array where index corresponds to the table and value is how many people are at that table
choices: array where index corresponds to the person (out of `n`) and value is the table where that person sits
*/



// Helper function: find prob of person n sitting at a table with b people at the table
var tableProb = function (b, n, alpha) {
  return b != 0 ? b / (n + alpha) : alpha / (n + alpha);
};

// Given array `tableCounts` of how many people are at each table, assign a table to a new person
var findTable = function (tableCounts, alpha) {
  // console.log("Table counts: " + tableCounts)
  var n = _.sum(tableCounts); // number of people already seated
  var _tableCounts = tableCounts.concat([0]); // add unoccupied table to end of array for purpose of calculating probabilities

  var currentTableProb = function (b) {
    return tableProb(b, n, alpha);
  };

  var tableProbs = map(currentTableProb, _tableCounts);

  console.assert(Math.abs(_.sum(tableProbs) - 1) < 0.0001);
  return sample(Discrete({ ps: tableProbs }));
};

// Update tableCounts based on table sampled for new person
var updateTable = function (tableNums, alpha) {
  var newTable = findTable(tableNums, alpha);
  var nTables = tableNums.length;

  if (nTables == 0) { // if there are no occupied tables yet, assign first person to table 0
    var _tableNums = [1];
    return {
      tables: _tableNums,
      choice: 0
    };
  } else if (nTables == newTable) {  // If we occupy a new table, add 1 to the end of `tableNums`
    var _tableNums = tableNums.concat([1]);
    return {
      tables: _tableNums,
      choice: newTable
    };
  } else { // if any other table gets occupied then increment the count for that table by 1

    var incrementIfNewTable = function (val, idx) {
      if (idx == newTable) {
        return val + 1;
      } else {
        return val;
      }
    }

    var _tableNums = map2(incrementIfNewTable, tableNums, _.range(0, tableNums.length))

    return {
      tables: _tableNums,
      choice: newTable
    };
  };
};


var CRP = function (n, alpha) {

  var iterate = function (n, tablesSoFar, choicesSoFar) {

    var updatedTables = updateTable(tablesSoFar, alpha);
    var _tablesSoFar = updatedTables.tables;
    var newChoice = updatedTables.choice;

    var _choicesSoFar = choicesSoFar.concat([newChoice]);
    var nChoicesSoFar = _choicesSoFar.length;
    if (nChoicesSoFar >= n) {
      return {
        tableCounts: _tablesSoFar,
        choices: _choicesSoFar
      };
    } else {
      return iterate(n, _tablesSoFar, _choicesSoFar);
    }
  }

  var output = iterate(n, [], []);
  // console.log("Final table counts: " + output.tableCounts);
  return output;

};

var sampleGroupsCRP = function (nPartners, alpha) {
  var _sample = CRP(nPartners, alpha);
  var nGroups = _sample.tableCounts.length
  var _choices = _sample.choices;

  // make list of groups and partners
  var _groups = mapN(function (x) { return 'group' + x }, nGroups);
  var _partners = mapN(function (x) { return 'partner' + x }, nPartners);
  var _assignments = map(function (x) { return 'group' + x }, _choices)

  var result = agent.convertToObj(_partners, _assignments)
  return {
      groups: _groups,  // list of groups
      partners: _partners,
      assignments: _assignments,
      groupAssignments: result  // object of group assignments; key is partner
  }
};