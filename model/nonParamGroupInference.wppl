// const { extend } = require("datalib/src/util");

/*
Nonparametric group inference with CRP prior

webppl nonParamGroupInference.wppl --require ./agent/ --require webppl-csv -- --gameNum 'game1'
*/
var utterances = ['word1', 'word2'];
var objects = ['A', 'B'];
var meanings = ['A', 'B'];
var numMeanings = meanings.length;
var partners = ['partner0', 'partner1', 'partner2', 'partner3'];
var model = 'FlexibleListenerGroups'

var params = {
    speakerAlpha: 5,
    listenerAlpha: 5,
    discountFactor: 0.9,
    guessingEpsilon: 0.01,
    costWeight: 0,
    numTrials: 24,
    context: objects,
    utterances: utterances,
    objects: objects,
    inferOptions: { method: 'MCMC', samples: 8000, burn: 5000, lag: 5, verbose: false },
    model: model,
    scalingFactor: 1,
    priorAlpha: 1.5,  // CRP prior
    nPartners: partners.length
};


// Functions for saving data
var f = csv.open('./output/nonparam/' + model + '_alpha' + params.priorAlpha + 'scale' + params.scalingFactor + '.csv');
csv.writeLine('model,speakerAlpha,listenerAlpha,costWeight,discountFactor,guessingEpsilon,scalingFactor,priorAlpha,iterationNum,trialNum,speakerID,listenerID,partnerID,intendedName,speakerChoice,listenerChoice,correctProb', f);

var writeLine = function (iterationNum, currTrial, speakerChoice, listenerChoice, listenerOutput) {
    csv.writeLine([
        params.model,
        params.speakerAlpha,
        params.listenerAlpha,
        params.costWeight,
        params.discountFactor,
        params.guessingEpsilon,
        params.scalingFactor,
        params.priorAlpha,
        iterationNum,
        currTrial.trialNum,
        currTrial.speakerID,
        currTrial.listenerID,
        currTrial.partnerID,
        currTrial.intendedName,
        speakerChoice,
        listenerChoice,
        listenerOutput.score(currTrial.intendedName),  // probability of listener being correct
    ].join(','), f);
};

var postTest = function (iterationNum, trial, posterior) {
    var data = [params.model, params.speakerAlpha, params.listenerAlpha, params.discountFactor, params.guessingEpsilon,
        iterationNum, trial.trialNum];
    map(function (partner) {
        //console.log(marginalize(posterior, function(x){return x[partner]}))
        agent.writeMarginals(marginalize(posterior, function (x) { return x[partner]; }),
            posttest_file, data.concat([trial.speakerID, trial.listenerID, partner]));
    }, partners);
}

var posttest_file = csv.open('./output/nonparam/meaningTest_' + model + '_alpha' + params.priorAlpha + 'scale' + params.scalingFactor + '.csv');
csv.writeLine('model,speakerAlpha,listenerAlpha,discountFactor,guessingEpsilon,iterationNum,trialNum,speakerID,listenerID,partnerID,partner,val', posttest_file);



////////////////////////////////////
////////////////////////////////////

// Function for sampling groups
var sampleGroups = function (nPartners, alpha) {
    var _sample = CRP(nPartners, alpha);
    var nGroups = _sample.tableCounts.length
    var _choices = _sample.choices;

    // make list of groups and partners
    var _groups = mapN(function (x) { return 'group' + x }, nGroups);
    var _partners = mapN(function (x) { return 'partner' + x }, nPartners);
    var _assignments = map(function (x) { return 'group' + x }, _choices)

    var result = agent.convertToObj(_partners, _assignments)
    return {
        groups: _groups,  // list of groups
        partners: _partners,
        assignments: _assignments,
        groupAssignments: result  // object of group assignments; key is partner
    }
};

//

var sampleProbs = function () {
    return T.mul(ones([numMeanings, 1]), params.scalingFactor);
}

var lexicalPrior = function () {
    var groupSample = sampleGroups(params.nPartners, params.priorAlpha);
    // console.log(groupSample.groups)
    var groupAssignmentZ = groupSample.groupAssignments

    var meaning = map(function (utt) {
        var hyperParamsList = map(mem(function (x) { return dirichlet(sampleProbs()) }), groupSample.groups);
        // console.log(hyperParamsList)
        var hyperParams = agent.convertToObj(groupSample.groups, hyperParamsList) // this might not work
        return extend(hyperParams,
            {
                partnerMeaning: map(function (id) {
                    var partnerGroup = groupAssignmentZ[id];
                    return categorical({ vs: meanings, ps: hyperParams[partnerGroup] });
                }, partners)
            });
    }, utterances);

    var hyperParamsVals = map(function (grp) { return { 'word1': meaning[0][grp], 'word2': meaning[1][grp] } }, groupSample.groups)
    // console.log(hyperParamsVals)
    var hyperParamsDict = agent.convertToObj(groupSample.groups, hyperParamsVals)
    // console.log(hyperParamsDict)
    // console.log(meaning[0].partnerMeaning[0])
    // console.log(meaning)
    return {
        groupAssignment: groupAssignmentZ,
        hyperParams: hyperParamsDict,
        lexicon: { // each entry is for a specific partner
            0: {
                'word1': meaning[0].partnerMeaning[0], 'word2': meaning[1].partnerMeaning[0]
            },
            1: {
                'word1': meaning[0].partnerMeaning[1], 'word2': meaning[1].partnerMeaning[1]
            },
            2: {
                'word1': meaning[0].partnerMeaning[2], 'word2': meaning[1].partnerMeaning[2]
            },
            3: {
                'word1': meaning[0].partnerMeaning[3], 'word2': meaning[1].partnerMeaning[3]
            }
        }
    }
};

var iterate = function (iterationNum, outputF, remainingTrials, dataSoFar) {
    var currTrial = extend(first(remainingTrials), {
        context: params.context,
    });

    console.log('Iteration ' + iterationNum + ' Trial ' + currTrial.trialNum + ' Scale ' + params.scalingFactor);

    var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID], lexicalPrior, params);
    var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID], lexicalPrior, params);
    postTest(iterationNum, currTrial, marginalize(listenerPosterior, 'groupAssignment')); //listener-focus

    // get marginal prediction of next data point over lexicon posterior
    var trialParams = extend(params, { partnerID: currTrial.partnerID, speakerID: currTrial.speakerID });
    var speakerOutput = S(currTrial.intendedName, speakerPosterior, trialParams);
    var nextUtt = sample(speakerOutput); // speaker-focus

    var listenerOutput = L(nextUtt, listenerPosterior, trialParams);
    var nextChoice = sample(listenerOutput); // listener-focus

    writeLine(iterationNum, currTrial, nextUtt, nextChoice, listenerOutput);
    var newDataSoFar = _.zipObject(_.range(0, 5), map(function (id) {
        var trialPacket = extend(currTrial, {
            role: id == currTrial.speakerID ? "speaker" : "listener",
            wordID: nextUtt,
            clickedName: nextChoice
        });
        return (id == currTrial.speakerID || id == currTrial.listenerID ?
            dataSoFar[id].concat(trialPacket) : dataSoFar[id]);
    }, _.range(0, 5)));

    if (!_.isEmpty(rest(remainingTrials))) {
        iterate(iterationNum, outputF, rest(remainingTrials), newDataSoFar);
    }
};

var trials = [

    // Context 1 Set: Same listener for all trials, Group 1: 1 & 3, Group 2: 2 & 4 --------------------------------
    // Group 1 refers to A as "word1" and B as "word2"
    // Group 2 refers to A as "word2" and B as "word1"

    { trialNum: 1, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 2, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 3, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 4, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 5, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 6, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 7, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 8, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 9, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 10, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 11, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 12, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 13, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 14, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 15, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 16, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 17, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 18, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 19, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 20, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 21, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 22, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 23, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 24, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' }

    // Context 1 Set: Same speaker for all trials, Group 1: 1 & 3, Group 2: 2 & 4 --------------------------------
    // Group 1 refers to A as "word1" and B as "word2"
    // Group 2 refers to A as "word2" and B as "word1"

    //  {trialNum: 1, speakerID: 5, listenerID: 1, partnerID: 1, intendedName: 'A'},
    //  {trialNum: 2, speakerID: 5, listenerID: 1, partnerID: 1, intendedName: 'B'},
    //  {trialNum: 3, speakerID: 5, listenerID: 1, partnerID: 1, intendedName: 'A'},
    //  {trialNum: 4, speakerID: 5, listenerID: 1, partnerID: 1, intendedName: 'B'},
    //  {trialNum: 5, speakerID: 5, listenerID: 1, partnerID: 1, intendedName: 'A'},
    //  {trialNum: 6, speakerID: 5, listenerID: 1, partnerID: 1, intendedName: 'B'},
    //  {trialNum: 7, speakerID: 5, listenerID: 2, partnerID: 2, intendedName: 'A'},
    //  {trialNum: 8, speakerID: 5, listenerID: 2, partnerID: 2, intendedName: 'B'},
    //  {trialNum: 9, speakerID: 5, listenerID: 2, partnerID: 2, intendedName: 'A'},
    //  {trialNum: 10, speakerID: 5, listenerID: 2, partnerID: 2, intendedName: 'B'},
    //  {trialNum: 11, speakerID: 5, listenerID: 2, partnerID: 2, intendedName: 'A'},
    //  {trialNum: 12, speakerID: 5, listenerID: 2, partnerID: 2, intendedName: 'B'},
    //  {trialNum: 13, speakerID: 5, listenerID: 3, partnerID: 3, intendedName: 'A'},
    //  {trialNum: 14, speakerID: 5, listenerID: 3, partnerID: 3, intendedName: 'B'},
    //  {trialNum: 15, speakerID: 5, listenerID: 3, partnerID: 3, intendedName: 'A'},
    //  {trialNum: 16, speakerID: 5, listenerID: 3, partnerID: 3, intendedName: 'B'},
    //  {trialNum: 17, speakerID: 5, listenerID: 3, partnerID: 3, intendedName: 'A'},
    //  {trialNum: 18, speakerID: 5, listenerID: 3, partnerID: 3, intendedName: 'B'},
    //  {trialNum: 19, speakerID: 5, listenerID: 4, partnerID: 4, intendedName: 'A'},
    //  {trialNum: 20, speakerID: 5, listenerID: 4, partnerID: 4, intendedName: 'B'},
    //  {trialNum: 21, speakerID: 5, listenerID: 4, partnerID: 4, intendedName: 'A'},
    //  {trialNum: 22, speakerID: 5, listenerID: 4, partnerID: 4, intendedName: 'B'},
    //  {trialNum: 23, speakerID: 5, listenerID: 4, partnerID: 4, intendedName: 'A'},
    //  {trialNum: 24, speakerID: 5, listenerID: 4, partnerID: 4, intendedName: 'B'}

];

map(function (i) {
    console.log('iteration', i);
    iterate(i, f, trials, { 0: [], 1: [], 2: [], 3: [], 4: [] }); // 1 thru 5 are diff participants
}, _.range(100));

csv.close(f);
csv.close(posttest_file);
