/*
Nonparametric group inference with DP prior

webppl nonParamGroupInference.wppl --require ./agent/ --require webppl-csv -- --gameNum 'game1'
*/

var utterances = ['word1', 'word2'];
var objects = ['A', 'B'];
var meanings = ['A', 'B'];
var numMeanings = meanings.length;
var partners = [0, 1, 2, 3];
var model = 'nonparam'

var params = {
    speakerAlpha: 1,
    listenerAlpha: 1,
    discountFactor: 1,
    guessingEpsilon: 0.01, // 0.01
    costWeight: 0,
    numTrials: 24,
    context: objects,
    utterances: utterances,
    objects: objects,
    inferOptions: { method: 'MCMC', samples: 15000, burn: 5000, lag: 5, verbose: false },
    model: model,
    scalingFactor: 0.1,
    priorAlpha: 0.5,  // concentration parameter for DP
    nPartners: partners.length
};


///// Functions for saving data

var f = csv.open('./output/nonparam/' + model + '_a' + params.priorAlpha + 's' + params.scalingFactor + 'd' + params.discountFactor + 'g' + params.guessingEpsilon + '_' + params.numTrials + '.csv');
csv.writeLine('model,speakerAlpha,listenerAlpha,costWeight,discountFactor,guessingEpsilon,scalingFactor,priorAlpha,iterationNum,trialNum,speakerID,listenerID,partnerID,intendedName,speakerChoice,listenerChoice,correctProb', f);

var writeLine = function (iterationNum, currTrial, speakerChoice, listenerChoice, listenerOutput) {
    csv.writeLine([
        params.model,
        params.speakerAlpha,
        params.listenerAlpha,
        params.costWeight,
        params.discountFactor,
        params.guessingEpsilon,
        params.scalingFactor,
        params.priorAlpha,
        iterationNum,
        currTrial.trialNum,
        currTrial.speakerID,
        currTrial.listenerID,
        currTrial.partnerID,
        currTrial.intendedName,
        speakerChoice,
        listenerChoice,
        listenerOutput.score(currTrial.intendedName),  // probability of listener being correct
    ].join(','), f);
};

var postTestPartner = function (iterationNum, trial, posterior) {
    var data = [params.model, params.speakerAlpha, params.listenerAlpha, params.discountFactor, params.guessingEpsilon, params.priorAlpha,
        iterationNum, trial.trialNum];
    map(function (partner) {
        //console.log(marginalize(posterior, function(x){return x[partner]}))
        agent.writeMarginals(marginalize(posterior, function (x) { return x[partner]; }),
            posttest_file, data.concat([trial.speakerID, trial.listenerID, partner]));
    }, partners);
}

var writePartitionMarginals = function (iterationNum, trial, posterior) {
    var data = [params.model, params.speakerAlpha, params.listenerAlpha, params.discountFactor, params.guessingEpsilon, params.priorAlpha,
        iterationNum, trial.trialNum];

    agent.writeMarginals(marginalize(posterior, 'partition'),
        posttest_file, data.concat([trial.speakerID, trial.listenerID, NaN]));
}


var posttest_file = csv.open('./output/nonparam/meaningTest_' + model + '_a' + params.priorAlpha + 's' + params.scalingFactor + 'd' + params.discountFactor + 'g' + params.guessingEpsilon + '_' + params.numTrials + '.csv');
csv.writeLine('model,speakerAlpha,listenerAlpha,discountFactor,guessingEpsilon,priorAlpha,iterationNum,trialNum,speakerID,listenerID,partnerID,result,val', posttest_file);



var hyperHypers = T.mul(ones([numMeanings, 1]), params.scalingFactor)

///// Model
var updatePosterior = function (data, params) {
    return Infer(params.inferOptions, function () {


        // for each unique partner, sample a group
        var makeGroup = mem(function (partnerID) {
            var sticks = mem(function (index) { return beta(1, params.priorAlpha) });

            var findStick = function (sticks, J) {
                return flip(sticks(J)) ? J : findStick(sticks, J + 1);
            };

            var groupIdx = findStick(sticks, 0);

            // Assign label to group
            return groupIdx
        })

        // each group has its own hyperparams
        var makeGroupHypers = mem(function (group) {
            return {
                word1probs: dirichlet(hyperHypers),
                word2probs: dirichlet(hyperHypers)
            }
        })

        // from the group's hyperparams, sample meanings
        var makeLexicon = function (hypers) {
            var meanings = [categorical({ vs: meanings, ps: hypers.word1probs }),
            categorical({ vs: meanings, ps: hypers.word2probs })]

            var lexicon = _.zipObject(utterances, meanings)

            return lexicon
        }

        var groupAssignments = _.zipObject(partners, map(function (partner) { return makeGroup(partner) }, partners))
        var lexicons = _.zipObject(partners, map(function (partner) { return makeLexicon(makeGroupHypers(_.get(groupAssignments, partner))) }, partners))
        var sameGroupAsPartner0 = _.zipObject(partners, map(function (partner) { return makeGroup(partner) == makeGroup(0) }, partners))


        var obsFn = function (trial) {

            var beta = Math.pow(params.discountFactor, data.length - trial.trialNum);
            var object = trial.role == 'speaker' ? trial.clickedName : trial.intendedName;

            var trialParams = extend(params, { context: trial.context, lexicon: lexicons[trial.partnerID] }); // lexicon: makeLexicon(group)
            if (trial.role == 'speaker') {
                factor(beta * agent.getL0Score(object, trial.wordID, trialParams));
            } else {
                factor(beta * agent.getS1Score(trial.wordID, object, trialParams));
            };

        }

        mapData({ data: data }, obsFn)

        // make partitions
        var isSameGroup = function (alice, bob) { return makeGroup(alice) === makeGroup(bob) }
        var partition = groupBy(isSameGroup, partners)
        var partitionString = reduce(function (x, acc) { return "{" + x + "}" + acc }, "", partition) // yikes but... works lol

        return {
            lexicon: lexicons,
            groupAssignments: groupAssignments,
            sameGroup0: sameGroupAsPartner0,
            partition: "\"" + partitionString + "\""
        };
    });
};


var iterate = function (iterationNum, outputF, remainingTrials, dataSoFar) {
    var currTrial = extend(first(remainingTrials), {
        context: params.context,
    });

    console.log('Iteration ' + iterationNum + ' Trial ' + currTrial.trialNum + ' Scale ' + params.scalingFactor);

    var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID], params);
    var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID], params);
    // console.log(marginalize(listenerPosterior, 'lexicon'))
    // console.log(marginalize(listenerPosterior, 'partition'))

    var lexiconPosterior = marginalize(listenerPosterior, 'lexicon')
    var top5Lexicons = Infer({ method: 'enumerate', maxExecutions: 5, strategy: 'likelyFirst' },
        function () {
            return sample(lexiconPosterior);
        })

    console.log(top5Lexicons)
    console.log(marginalize(listenerPosterior, 'partition'))

    // postTestPartner(iterationNum, currTrial, marginalize(listenerPosterior, 'groupAssignments')); //listener-focus
    // postTestPartner(iterationNum, currTrial, marginalize(listenerPosterior, 'sameGroup0')); //listener-focus
    // postTestPartner(iterationNum, currTrial, marginalize(listenerPosterior, 'lexicon')); //listener-focus

    writePartitionMarginals(iterationNum, currTrial, listenerPosterior);

    // get marginal prediction of next data point over lexicon posterior

    var trialParams = extend(params, { partnerID: currTrial.partnerID, speakerID: currTrial.speakerID });
    var speakerOutput = S(currTrial.intendedName, speakerPosterior, trialParams);
    var nextUtt = sample(speakerOutput); // speaker-focus

    var listenerOutput = L(nextUtt, listenerPosterior, trialParams);
    var nextChoice = sample(listenerOutput); // listener-focus

    writeLine(iterationNum, currTrial, nextUtt, nextChoice, listenerOutput);
    var newDataSoFar = _.zipObject(_.range(0, 5), map(function (id) {
        var trialPacket = extend(currTrial, {
            role: id == currTrial.speakerID ? "speaker" : "listener",
            wordID: nextUtt,
            clickedName: nextChoice
        });
        return (id == currTrial.speakerID || id == currTrial.listenerID ?
            dataSoFar[id].concat(trialPacket) : dataSoFar[id]);
    }, _.range(0, 5)));

    if (!_.isEmpty(rest(remainingTrials))) {
        iterate(iterationNum, outputF, rest(remainingTrials), newDataSoFar);
    }
};


var trials = [

    // Context 1 Set: Same listener for all trials, Group 1: 0 & 2, Group 2: 1 & 3
    // Group 1 refers to A as "word1" and B as "word2"
    // Group 2 refers to A as "word2" and B as "word1"

    // 6 trials per convo
    { trialNum: 1, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 2, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 3, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 4, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 5, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 6, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 7, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 8, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 9, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 10, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 11, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 12, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 13, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 14, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 15, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 16, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 17, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    { trialNum: 18, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    { trialNum: 19, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 20, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 21, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 22, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    { trialNum: 23, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    { trialNum: 24, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' }

    // morestuff: 12 trials per convo
    // { trialNum: 1, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 2, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 3, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 4, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 5, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 6, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 7, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 8, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 9, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 10, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 11, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 12, partnerID: 0, speakerID: 0, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 13, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 14, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 15, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 16, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 17, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 18, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 19, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 20, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 21, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 22, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 23, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 24, partnerID: 1, speakerID: 1, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 25, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 26, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 27, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 28, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 29, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 30, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 31, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 32, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 33, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 34, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 35, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'A', wordID: 'word1' },
    // { trialNum: 36, partnerID: 2, speakerID: 2, listenerID: 4, intendedName: 'B', wordID: 'word2' },
    // { trialNum: 37, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 38, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 39, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 40, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 41, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 42, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 43, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 44, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 45, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 46, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' },
    // { trialNum: 47, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'A', wordID: 'word2' },
    // { trialNum: 48, partnerID: 3, speakerID: 3, listenerID: 4, intendedName: 'B', wordID: 'word1' }


];

map(function (i) {
    console.log('iteration', i);
    iterate(i, f, trials, { 0: [], 1: [], 2: [], 3: [], 4: [] }); // 1 thru 5 are diff participants
}, _.range(100));

csv.close(f);
csv.close(posttest_file);
