// run using, e.g.:
// webppl groupInference.wppl --require ./sharedInference/

// inference of speaker choosing an utterance
var S = function(object, posterior, params){
  var modelS = function(){
    // determining which community
    // var z = sample(Discrete({ps: params.groupDist}))
    // var community = posterior.groupUtt[z];

    // utterance chosen based on what they know about the community
    // var utt = categorical({ps: community, vs: params.utterances});
    var utt = uniformDraw(params.utterances);

    var inf = expectation(posterior, function(lexicon){
      return refModule.getL0Score(object, utt, extend(params, {lexicon: lexicon}))
    })
    var utility = ((1-params.costWeight)*inf - params.costWeight*utt.split('_').length);
    factor(params.speakerAlpha * utility);
    return utt;
  };

  return Infer({method: "enumerate"}, modelS);
};

// inference of listener choosing an object
var L = function(utt, posterior, params){
  var modelL = function(){
    // object chosen based on speaker community
    // var z = sample(Discrete({ps: params.groupDist}))
    // var community = posterior.groupObj[z];

    // var object = categorical({ps: community, vs: params.objects});
    var object = uniformDraw(params.objects);

    var inf = expectation(posterior, function(lexicon){
      return refModule.getSpeakerScore(utt, object, extend(params, {lexicon: lexicon}))
    });
    var utility = (inf);
    factor(params.listenerAlpha * utility);
    return object;
  };
  return Infer({method: "enumerate"}, modelL)
};

var updatePosterior = function(data, lexicalPrior, params){
  return Infer(params.inferOptions, function() {
    // global prototype
    var lexicon = lexicalPrior();

    // guessing the community
    // var groupUtt = repeat(params.numGroups, function (){
    //   // distribution within each community
    //   return dirichlet({alpha: ones([params.utterances.length, 1])})
    // })
    // var groupObj = repeat(params.numGroups, function (){
    //   // distribution within each community
    //   return dirichlet({alpha: ones([params.objects.length, 1])})
    // })

    // mapData({data: data}, function(trial) {
    //    var beta = Math.pow(params.discountFactor,  data.length - trial.trialNum);
    //    var object = trial.role == 'speaker' ? trial.clickedName : trial.intendedName;
    //    var trialParams = extend(params, {context: trial.context, lexicon: lexicon[trial.partnerID]});
    //    if(trial.role == 'speaker') {
    //      factor(beta * refModule.getL0Score(object, trial.wordID, trialParams));
    //    } else {
    //      factor(beta * refModule.getSpeakerScore(trial.wordID, object, trialParams));
    //    }
    // });

    // return {groupUtt: groupUtt.data, groupObj: groupObj.data};
    return lexicon;
  });
};

// setting up simulations

var utterances = ['word1', 'word2'];
var objects = ['circle', 'square'];
var meanings = ['circle', 'square'];
var numMeanings = meanings.length;
var groups = ['red', 'blue'];
var numGroups = groups.length;
var groupDist = dirichlet({alpha: ones([numGroups, 1])})

var params = {
  utterances: utterances,
  objects: objects,
  context: objects,
  states: objects,
  numGroups: numGroups,
  groupDist: groupDist,
  costWeight: 0,
  speakerAlpha: 1,
  listenerAlpha: 1,
  inferOptions: {method: 'MCMC', samples: 20000}
}

var lexicalPrior = function() {
  return _.zipObject(utterances, map(function(utt) {
    return sample(Categorical({vs: meanings}));
  }, utterances))
};

// for each point in data, we want the model's predictions
var iterate = function(iterationNum, dataSoFar) {
  var trialNum = dataSoFar[1].length;
  var currTrial = {
    intendedName: uniformDraw(objects),
    trialNum: trialNum,
    partnerID: 1,
    speakerID: (trialNum % 2) == 0 ? 1 : 2,
    listenerID: (trialNum % 2) == 0 ? 2 : 1
  };

  var config = extend(params, {context: currTrial.context});
  var speakerPosterior = updatePosterior(dataSoFar[currTrial.speakerID], lexicalPrior, config);
  var listenerPosterior = updatePosterior(dataSoFar[currTrial.listenerID], lexicalPrior, config);

  // get marginal prediction of next data point over lexicon posterior
  var speakerOutput = S(currTrial.intendedName, speakerPosterior, config);
  var topSpeakerChoice =  sample(speakerOutput);

  var listenerOutput = L(topSpeakerChoice, listenerPosterior, config);
  var topListenerChoice =  sample(listenerOutput);

  // writeLine(params, currTrial, topListenerChoice, topSpeakerChoice);
  if(currTrial.trialNum < params.numTrials) {
    var ids = [currTrial.speakerID, currTrial.listenerID];
    iterate(iterationNum, _.zipObject(ids, map(function(id) {
      return dataSoFar[id].concat(extend(currTrial, {
        role : id == currTrial.speakerID ? 'speaker' : 'listener',
        wordID : topSpeakerChoice,
        clickedName : topListenerChoice
      }));
    }, ids)));
  }
};

map(function(i) {
  console.log('iteration', i);
  iterate(i, {1: [], 2: []});
}, _.range(5));