---
title: "Experiment 1 analysis"
output: html_notebook
---


```{r}
library(tidyverse)
library(jsonlite)
library(here)
library(lme4)
library(lmerTest)
library(ggthemes)
library(tidyboot)

# this is a helper function to deal with the awful json columns
ParseJSONColumn <- function(x) {
   str_c("[ ", str_c(x, collapse = ",", sep=" "), " ]")  %>% 
     fromJSON(flatten = T)
}
```

```{r}
d.chat <- read_csv(here('data/rounds.csv')) %>%
  filter(createdAt >= lubridate::ymd('2021-01-21')) %>%
  mutate(data.chat = ifelse(is.na(data.chat), '{}', data.chat)) %>%
  rename(row_id = `_id`) %>%
  mutate(data.chat = map(data.chat, .f = ParseJSONColumn)) %>%
  unnest(data.chat) %>%
  select(-data.target, -ends_with('response'), -ends_with('correct')) %>%
  rename_with(~ gsub("data.", "", .x, fixed = TRUE))

d.room_info <- read_csv(here('data/rounds.csv')) %>%
  filter(createdAt >= lubridate::ymd('2021-01-21')) %>%
  mutate(data.target = map(data.target, .f = ParseJSONColumn)) %>%
  unnest(data.target) %>%
  rename(room0_target = room0, room1_target = room1) %>%
  filter(!is.na(text)) %>%
  rename_with(~ gsub("data.", "", .x, fixed = TRUE)) %>%
  rename(room1_response = room1response, room0_response = room0response) %>%
  select(-room0data, -room1data, -ends_with('correct'), -chat) %>%
  gather(key, value, starts_with('room')) %>%
  separate(key, into = c('roomId', 'info')) %>%
  spread(info, value) %>%
  mutate(response = ifelse(response == 'false', 'timed_out', response))
```

Get exit survey responses

```{r}
d.exit.survey <- read_csv(here('data/player-inputs.csv')) %>%
  filter(createdAt >= lubridate::ymd('2021-01-21')) %>%
  filter(!is.na(data.community)) %>%
  left_join(read_csv(here('data/games.csv')) %>% rename(gameId = `_id`),
            by = c('gameId')) %>%
  select(where(~ !any(is.na(.))))

correct_community_response <- d.exit.survey %>%
  filter(data.community == data.teamColor) %>%
  pull(playerId)

english_native_language <- d.exit.survey %>%
  filter(data.english == 'yes') %>%
  pull(playerId)
```

```{r}
roles.tmp <- read_csv(here('data/games.csv')) %>% 
  rename(gameId = `_id`) %>%
  select(gameId, data.roleList) %>%
  mutate(data.roleList = map(data.roleList, .f = ParseJSONColumn)) %>%
  unnest(data.roleList) %>%
  gather(playerId, role, -gameId) %>%
   rowwise() %>%
  filter(!is.null(role)) %>%
  unnest(role) %>%
  group_by(playerId) %>%
  mutate(n = row_number() - 1,
         trialNum = n %% 16,
         partnerNum = floor(n / 16),
         repNum = floor(trialNum/4) %% 4) %>%
  select(-n)

roles <- d.chat %>%
  ungroup() %>%
  mutate(row_id = row_number()) %>%
  group_by(gameId, partnerNum, roomId, trialNum, repNum) %>%
  filter(row_id == first(row_id)) %>%
  group_by( gameId, partnerNum, roomId) %>%
  summarize(playerId = unique(playerId)) %>%
  left_join(roles.tmp) %>%
  group_by(gameId, partnerNum, roomId, trialNum, repNum) %>%
  filter(!is.na(roomId)) %>%
  spread(role, playerId)
```

Look at complete games (where at least one message was sent on every round)

```{r}
time_outs <- d.room_info %>%
  left_join(roles) %>%
  group_by(listener, partnerNum, response) %>%
  tally() %>%
  filter(response == 'timed_out' | is.na(response)) %>%
  filter(!is.na(listener)) %>%
  group_by(listener, partnerNum) %>%
  summarize(totalTimeouts = sum(n))
```

Fewer timeouts as the game proceeds (need to be careful about this as a confound with accuracy).

```{r}
time_outs %>%
  ggplot(aes(x = totalTimeouts)) +
    geom_histogram(bins = 5) +
    geom_density(aes(y = ..count..), adjust = 3) +
    facet_wrap(~ partnerNum)
```

Overall distribution of total timeouts per participant.

```{r}
time_outs %>%
  group_by(listener) %>%
  summarize(totalTimeouts = sum(totalTimeouts))  %>%
  ggplot(aes(x = totalTimeouts)) +
    geom_histogram(bins = 24) +
    theme_few()
```
Some games had a number of rounds go by where no one talked (one possible upstream reason for timeouts...)

```{r}
talked <- d.chat %>%
  filter(!is.na(text)) %>%
  group_by(gameId, trialNum, roomId, partnerNum) %>%
  tally() %>%
  group_by(gameId) %>%
  tally() %>%
  filter(n >= 90) %>%
  pull(gameId)
```

# Behavioral results during game 

accuracy over time.

```{r}
d.room_info %>%
  filter(gameId %in% talked) %>%
  select(gameId, trialNum, partnerNum, repNum, roomId, response, target) %>%
  # Remove trials that timed out (so not confounded by attention effects)
  filter(response != 'timed_out') %>%
  mutate(correct = response == target) %>%
  group_by(partnerNum, repNum) %>%
  tidyboot::tidyboot_mean(correct) %>%
  ggplot(aes(x = repNum, y = empirical_stat)) +
    geom_line() +
    geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0) +
    facet_grid(. ~ partnerNum) +
    theme_few()
```

Utterance length over time.

```{r}
d.chat %>%
  filter(gameId %in% talked) %>%
  filter(role == 'speaker') %>%
  mutate(text = gsub("\\n", '', fixed = T, text),
         text = gsub("[/?/.]", ' ', text),
         text = str_squish(text),
         utt_length_chars = str_length(text), 
         utt_length_words = str_count(text, "\\W+") + 1) %>%
  group_by(gameId, trialNum, partnerNum, repNum, roomId) %>%
  summarize(total_num_words = sum(utt_length_words),
            total_num_chars = sum(utt_length_chars)) %>%
  group_by(partnerNum, repNum) %>%
 tidyboot_mean(total_num_words) %>%
  ggplot(aes(x = repNum, y = empirical_stat)) +
    geom_line() +
    geom_errorbar(aes(ymin = ci_lower, ymax = ci_upper), width = 0) +
    facet_grid(. ~ partnerNum) +
    theme_few()
```

```{r}
post_test.raw <- read_csv(here('data/player-inputs.csv')) %>%
  filter(gameId %in% talked) %>%
  filter(playerId %in% correct_community_response) %>%
  mutate(low_timeout = playerId %in% sufficiently_low_timeouts) %>%
  rename_with(~ gsub("data.", "", .x, fixed = TRUE)) %>%
  mutate(text = gsub("\\n", '', fixed = T, text),
         text = gsub("[/?/.]", ' ', text),
         text = str_squish(text),
         utt_length_chars = str_length(text), 
         utt_length_words = str_count(text, "\\W+") + 1,
         ownGroup = ifelse(ownGroup == group, 'ownGroup', 'otherGroup')) %>%
  group_by(playerId) %>%
  mutate(blockOrder = ifelse(row_number() <= 4, 'first', 'second')) %>%
  filter(!is.na(text))

full_post_test <- post_test.raw %>%
  group_by(gameId) %>% 
  tally() %>%
  filter(n == 32) %>%
  pull(gameId)

cat('we have', length(full_post_test), 'networks where all 4 participants gave post-test responses.\n')
cat("that's", length(unique(post_test$playerId)), 'individual participants')
```

```{r}
post_test <- post_test.raw %>%
  filter(gameId %in% full_post_test)

total_avg <- post_test %>%
  group_by(ownGroup) %>%
  tidyboot::tidyboot_mean(utt_length_words, nboot = 100) %>%
  select(-n, -mean) %>%
  pivot_wider(names_from = ownGroup, values_from = c('empirical_stat', 'ci_lower', 'ci_upper')) 

post_test %>%
  group_by(gameId, playerId, ownGroup) %>%
  summarize(m = mean(utt_length_words)) %>%
  spread(ownGroup, m) %>%
  ggplot(aes(x = log(ownGroup), y = log(otherGroup), color = ownGroup > otherGroup)) +
    geom_point() +
    geom_abline(aes(intercept = 0, slope = 1), linetype = 'dotted') +
    ggthemes::theme_few() +
    ylim(0, 3.5) +
    xlim(0, 3.5) +
    labs(x = 'log # words for own group', y = 'log # words for other group') +
    theme(aspect.ratio = 1)
```

```{r}
error_bars <- post_test %>%
  group_by(ownGroup) %>%
  tidyboot::tidyboot_mean(utt_length_words, nboot = 100) %>%
  mutate(goingUp = TRUE)

post_test %>%
  group_by(gameId, playerId, ownGroup) %>%
  summarize(m = log(mean(utt_length_words))) %>%
  spread(ownGroup, m) %>%
  mutate(goingUp = otherGroup > ownGroup) %>%
  gather(ownGroup, m, otherGroup, ownGroup) %>%
  ggplot(aes(x = ownGroup, y = m, color = goingUp)) +
    geom_line(aes(group = playerId), alpha = 0.25) +
    geom_point(aes(x = ownGroup, y = log(empirical_stat)), 
               data = error_bars) +
    geom_errorbar(aes(ymin = log(ci_lower), ymax = log(ci_upper), 
                      x = ownGroup, y = log(empirical_stat)), 
                  width = 0,
                  data = error_bars) +
    geom_line(aes(x = ownGroup, group = 1, y = log(empirical_stat)), data = error_bars) +
    theme_bw() +
    labs(x = '', y = 'log # words') +
    theme(aspect.ratio = 1)
```

```{r}
library(lme4)
library(lmerTest)
post_test %>%
  select(playerId, gameId, tangram,  ownGroup,low_timeout,blockOrder, utt_length_words) %>%
  lmer(log(utt_length_words) ~ ownGroup + blockOrder 
                               + (1  + ownGroup + blockOrder | playerId) 
                               + (1 | gameId) 
                               + (1 | tangram),
       control = lmerControl(optimizer = 'bobyqa'),
       data = .) %>%
  summary()
```

```{r}
post_test %>%
  select(playerId, gameId, tangram, ownGroup, utt_length_words) %>%
  spread(ownGroup, utt_length_words) %>%
  ungroup() %>%
  summarize(result = list(t.test(.$ownGroup, .$otherGroup, paired = T))) %>%
  pull(result) 
```

```{r}
qualitative.direction <- post_test %>%
  group_by(gameId, playerId, ownGroup) %>%
  summarize(m = mean(utt_length_words)) %>%
  select(playerId, ownGroup, m) %>%
  spread(ownGroup, m) %>%
  mutate(qualitative = case_when(otherGroup > ownGroup ~ 'more',
                                 otherGroup == ownGroup ~ 'same',
                                 TRUE ~ 'less')) 

less_informative_to_other_group <- qualitative.direction %>%
  filter(qualitative=='less') %>%
  pull(playerId)

qualitative.direction %>%
  group_by(qualitative) %>%
  tally() %>%
  mutate(prop = n / sum(n))
```

Look at specific cases where people provided shorter description to other group

* playerId 2iWCDAdpFvRCNSrEM gave informative descriptions to own community and then just 'those are squares and diamonds' to other group
* check possible effect of block order...

```{r}
post_test %>%
  filter(playerId %in% less_informative_to_other_group) %>%
  select(playerId, gameId, tangram, ownGroup, text) %>%
  spread(ownGroup, text) %>%
  View()
```

```{r}
bonuses <- read_csv(here('data/players.csv')) %>%
  rename_with(~ gsub("data.", "", .x, fixed = TRUE)) %>%
  select(id, bonus) %>%
  filter(!is.na(bonus)) %>%
  filter(bonus > 0)

bonuses %>%
  slice_tail(n = 182) %>%
  mutate(bonus = round(bonus + 0.8,2)) %>%
  write_csv('to_bonus.csv')
```
